streams:
  inventory_updates:
    topic: inventory_updates
    keyType: string  # product_id
    valueType: json  # inventory data

  order_events:
    topic: order_events
    keyType: string  # order_id
    valueType: json  # order data

  product_reference:
    topic: product_reference
    keyType: string  # product_id
    valueType: json  # product details including thresholds

  reorder_events:
    topic: reorder_events
    keyType: string  # event_id
    valueType: json  # reorder data

  inventory_alerts:
    topic: inventory_alerts
    keyType: string  # alert_id
    valueType: json  # alert data

functions:
  generate_reorder_event:
    type: mapValues
    parameters:
      - name: inventory
        type: object
      - name: product_info
        type: object
    code: |
      import uuid
      import time

      # Get reorder threshold and quantity from product reference data
      reorder_threshold = product_info.get("reorder_threshold", 10)
      reorder_quantity = product_info.get("reorder_quantity", 50)

      # Determine priority based on current stock
      current_stock = inventory.get("current_stock", 0)
      priority = "urgent" if current_stock <= 5 else "normal"

      # Generate event ID
      event_id = f"reorder-{uuid.uuid4().hex[:8]}"

      # Create reorder event
      return {
        "event_id": event_id,
        "product_id": inventory.get("product_id"),
        "product_name": inventory.get("product_name"),
        "current_stock": current_stock,
        "reorder_quantity": reorder_quantity,
        "priority": priority,
        "warehouse_id": inventory.get("warehouse_id"),
        "timestamp": int(time.time() * 1000)
      }

  generate_alert:
    type: mapValues
    parameters:
      - name: inventory
        type: object
      - name: product_info
        type: object
    code: |
      import uuid
      import time

      # Get critical threshold from product reference data
      critical_threshold = product_info.get("critical_threshold", 5)

      # Get current stock
      current_stock = inventory.get("current_stock", 0)
      product_name = inventory.get("product_name", "Unknown Product")

      # Generate alert ID
      alert_id = f"alert-{uuid.uuid4().hex[:8]}"

      # Create alert message
      message = f"Critical inventory level: {product_name} ({current_stock} units remaining)"

      # Create alert event
      return {
        "alert_id": alert_id,
        "alert_type": "critical_inventory",
        "product_id": inventory.get("product_id"),
        "product_name": product_name,
        "current_stock": current_stock,
        "threshold": critical_threshold,
        "warehouse_id": inventory.get("warehouse_id"),
        "timestamp": int(time.time() * 1000),
        "message": message
      }

  update_inventory_from_order:
    type: mapValues
    parameters:
      - name: order
        type: object
      - name: inventory
        type: object
    code: |
      if inventory is None or order is None:
        return None

      # Find the item in the order that matches this product
      product_id = inventory.get("product_id")
      order_items = order.get("items", [])

      ordered_quantity = 0
      for item in order_items:
        if item.get("product_id") == product_id:
          ordered_quantity += item.get("quantity", 0)

      # If this product wasn't in the order, return unchanged inventory
      if ordered_quantity == 0:
        return None

      # Update inventory with new stock level
      current_stock = inventory.get("current_stock", 0)
      new_stock = max(0, current_stock - ordered_quantity)

      return {
        **inventory,
        "current_stock": new_stock,
        "last_order_id": order.get("order_id"),
        "last_updated": int(time.time() * 1000)
      }

pipelines:
  # Pipeline for detecting low inventory and generating reorder events
  reorder_pipeline:
    from: inventory_updates
    via:
      - type: join
        with: product_reference
      - type: filter
        if:
          code: |
            reorder_threshold = foreignValue.get("reorder_threshold", 10)
            return value.get("current_stock", 0) <= reorder_threshold
      - type: mapValues
        mapper:
          code: generate_reorder_event(value, foreignValue)
    to: reorder_events

  # Pipeline for detecting critical inventory levels and generating alerts
  alert_pipeline:
    from: inventory_updates
    via:
      - type: join
        with: product_reference
      - type: filter
        if:
          code: |
            critical_threshold = foreignValue.get("critical_threshold", 5)
            return value.get("current_stock", 0) <= critical_threshold
      - type: mapValues
        mapper:
          code: generate_alert(value, foreignValue)
    to: inventory_alerts

  # Pipeline for updating inventory based on orders
  order_processing_pipeline:
    from: order_events
    via:
      - type: flatMap
        mapper:
          code: |
            # For each item in the order, emit a key-value pair with product_id as key
            result = []
            for item in value.get("items", []):
              product_id = item.get("product_id")
              if product_id:
                result.append((product_id, value))
            return result
      - type: join
        with: inventory_updates
      - type: mapValues
        mapper:
          code: update_inventory_from_order(value, foreignValue)
      - type: filter
        if:
          expression: value is not None
    to: inventory_updates
