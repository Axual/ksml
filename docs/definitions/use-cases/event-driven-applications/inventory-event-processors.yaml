streams:
  order_events:
    topic: order_events
    keyType: string  # order_id
    valueType: json  # order data

  inventory_updates:
    topic: inventory_updates
    keyType: string  # product_id
    valueType: json  # alert data

  reorder_events:
    topic: reorder_events
    keyType: string  # event_id
    valueType: json  # reorder data

  inventory_alerts:
    topic: inventory_alerts
    keyType: string  # alert_id
    valueType: json  # alert data

tables:
  product_catalog:
    topic: product_catalog
    keyType: string  # product_id
    valueType: json  # product details including thresholds

stores:
  inventory_store:
    type: keyValue
    keyType: string
    valueType: json

pipelines:
  # Pipeline for updating inventory based on orders
  order_pipeline:
    from: order_events
    via:
      - type: transformKeyValueToKeyValueList
        mapper:
          code: |
            # For each item in the order, emit a key-value pair with product_id as key and ordered item as value
            result = []
            for item in value.get("items", []):
              product_id = item.get("product_id")
              if product_id:
                result.append((product_id, {**item, "order_id":key}))
            return result
          resultType: "[(string, struct)]"
      - type: peek
        forEach:
          code: |
            log.info("Ordered item: {}", value)
      - type: transformValue
        mapper:
          code: |
            inventory = inventory_store.get(key)
            if not inventory:
              inventory = {
                "product_id": key,
                "current_stock": 0
              }
            return {            
              "order_item": value,
              "inventory": inventory
            }
          resultType: struct
          stores:
            - inventory_store
      - type: peek
        forEach:
          code: |
            log.info("Looked up inventory: {}", value)
      - type: mapValues
        mapper:
          code: |
            # Get the product_id from the key
            product_id = key

            # Get the ordered item from the value
            order_item = value.get("order_item")
            if order_item is None:
              return None

            # Get the inventory from the value, or set to zero if no inventory found
            inventory = value.get("inventory")

            # Get the ordered amount
            ordered_quantity = order_item.get("quantity")
            if ordered_quantity == 0:
              return None
      
            # Update inventory with new stock level
            current_stock = inventory.get("current_stock", 0)
            new_stock = max(0, current_stock - ordered_quantity)

            # Update the inventory in the store
            value = {
              **inventory,
              "current_stock": new_stock,
              "last_order_id": order_item.get("order_id"),
              "last_updated": int(time.time() * 1000)
            }
            
            inventory_store.put(key, value)
            return value
          resultType: struct
          stores:
            - inventory_store
      # Only propagate valid inventory updates to the topic
      - type: filter
        if:
          expression: value is not None
      - type: peek
        forEach:
          code: |
            log.info("Updating inventory: {}", value)
    to: inventory_updates

  # Pipeline for detecting low inventory and generating reorder events
  reorder_pipeline:
    from: inventory_updates
    via:
      - type: join
        table: product_catalog
        valueJoiner:
          expression: |
            {
              "product": value2,
              "inventory": value1
            }
          resultType: struct
      - type: filter
        if:
          code: |
            product = value.get("product")
            inventory = value.get("inventory")
            return inventory.get("current_stock", 0) <= product.get("reorder_threshold", 0)
      - type: transformKeyValue
        mapper:
          globalCode: |
            import uuid
            import time
          code: |
            # Get reorder threshold and quantity from product reference data
            product = value.get("product")
            reorder_threshold = product.get("reorder_threshold", 10)
            reorder_quantity = product.get("reorder_quantity", 50)
      
            # Determine priority based on current stock
            inventory = value.get("inventory")
            current_stock = inventory.get("current_stock", 0)
            priority = "urgent" if current_stock <= 5 else "normal"
      
            # Generate event ID
            event_id = f"reorder-{uuid.uuid4().hex[:8]}"
      
            # Create reorder event
            value = {
              "event_id": event_id,
              "product_id": product.get("id"),
              "product_name": product.get("name"),
              "current_stock": current_stock,
              "reorder_quantity": reorder_quantity,
              "priority": priority,
              "timestamp": int(time.time() * 1000)
            }
          expression: (value.get("event_id"), value)
          resultType: (string, struct)
    to: reorder_events

  # Pipeline for detecting critical inventory levels and generating alerts
  alert_pipeline:
    from: inventory_updates
    via:
      - type: join
        table: product_catalog
        valueJoiner:
          expression: |
            {
              "product": value2,
              "inventory": value1
            }
          resultType: struct
      - type: filter
        if:
          code: |
            product = value.get("product")
            inventory = value.get("inventory")
            return inventory.get("current_stock", 0) <= product.get("critical_threshold", 0)
      - type: mapValues
        mapper:
          code: |
            import uuid
            import time

            # Get critical threshold from product reference data
            product = value.get("product")
            critical_threshold = product.get("critical_threshold", 5)
            product_name = product.get("name", "Unknown")
      
            # Get current stock
            inventory = value.get("inventory")
            current_stock = inventory.get("current_stock", 0)
      
            # Generate alert ID
            alert_id = f"alert-{uuid.uuid4().hex[:8]}"
      
            # Create alert message
            message = f"Critical inventory level: {product_name} ({current_stock} units remaining)"
      
            # Create alert event
            return {
              "alert_id": alert_id,
              "alert_type": "critical_inventory",
              "product_id": product.get("id"),
              "product_name": product_name,
              "current_stock": current_stock,
              "threshold": critical_threshold,
              "timestamp": int(time.time() * 1000),
              "message": message
            }
          resultType: struct
    to: inventory_alerts

  restock_pipeline:
    from: reorder_events
    via:
      - type: transformKey
        mapper:
          expression: value.get("product_id")
          resultType: string
      - type: transformValue
        mapper:
          code: |
            inventory = inventory_store.get(key)
            if not inventory:
              inventory = {
                "product_id": key,
                "current_stock": 0
              }
            return {
              "reorder": value,
              "inventory": inventory
            }
          resultType: struct
          stores:
            - inventory_store
      - type: transformValue
        mapper:
          code: |
            reorder = value.get("reorder")
            inventory = value.get("inventory")
            value = {
              **inventory,
              "current_stock": inventory.get("current_stock", 0) + reorder.get("reorder_quantity", 0),
              "last_reorder_id": reorder.get("event_id"),
              "last_updated": int(time.time() * 1000)
            }

            inventory_store.put(key, value)
            
            return value
          stores:
            - inventory_store
      - type: peek
        forEach:
          code: |
            log.info("Restocked product: {}", value)
    to: inventory_updates

  inventory_monitor:
    from: inventory_updates
    forEach:
      code: |
        log.info("Inventory updated: {}", value)
