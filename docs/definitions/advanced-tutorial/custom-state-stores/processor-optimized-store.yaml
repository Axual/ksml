# Processor demonstrating optimized state store configuration

streams:
  device_events:
    topic: device_events
    keyType: string
    valueType: json

stores:
  device_state_store:
    type: keyValue
    keyType: string
    valueType: string
    persistent: true
    caching: true
    # Optimized for high-volume scenarios

functions:
  process_device_events:
    type: valueTransformer
    stores:
      - device_state_store
    code: |
      import json
      import time
      
      # Extract fields from JSON event
      if not value:
        return None
      
      event_type = value.get("event_type")
      event_value = value.get("value")
      timestamp = value.get("timestamp")
      event_id = value.get("event_id")
      facility = value.get("facility")
      zone = value.get("zone")
      
      if not event_type or event_value is None or not timestamp:
        return None
      
      # Get existing device state
      state_str = device_state_store.get(key)
      if state_str:
        device_state = json.loads(state_str)
      else:
        device_state = {
          "device_id": key,
          "status": "unknown", 
          "last_temp": None, 
          "error_count": 0, 
          "last_seen": timestamp,
          "heartbeat_count": 0,
          "facility": facility,
          "zone": zone
        }
      
      # Process event efficiently with JSON output
      result_event = None
      
      if event_type == "sensor_reading":
        device_state["last_temp"] = float(event_value)
        device_state["status"] = "active"
        
        # Check for temperature alerts
        if device_state["last_temp"] > 75:
          result_event = {
            "alert_type": "TEMPERATURE_ALERT",
            "device_id": key,
            "temperature": device_state["last_temp"],
            "threshold": 75,
            "facility": facility,
            "zone": zone,
            "event_id": event_id,
            "timestamp": timestamp
          }
          log.warn("Temperature alert for device {}: {:.1f}C", key, device_state["last_temp"])
      
      elif event_type == "status_update":
        device_state["status"] = event_value
        result_event = {
          "alert_type": "STATUS_UPDATE",
          "device_id": key,
          "status": event_value,
          "facility": facility,
          "zone": zone,
          "event_id": event_id,
          "timestamp": timestamp
        }
        
      elif event_type == "error":
        device_state["error_count"] += 1
        device_state["status"] = "error"
        result_event = {
          "alert_type": "ERROR",
          "device_id": key,
          "error_code": event_value,
          "error_count": device_state["error_count"],
          "facility": facility,
          "zone": zone,
          "event_id": event_id,
          "timestamp": timestamp
        }
        log.error("Error on device {}: {} (total errors: {})", key, event_value, device_state["error_count"])
        
      elif event_type == "heartbeat":
        device_state["status"] = "online"
        device_state["heartbeat_count"] = device_state.get("heartbeat_count", 0) + 1
        # Only emit heartbeat summary every 10th heartbeat to reduce output volume
        if device_state["heartbeat_count"] % 10 == 0:
          result_event = {
            "alert_type": "HEARTBEAT_SUMMARY",
            "device_id": key,
            "status": "online",
            "heartbeat_count": device_state["heartbeat_count"],
            "facility": facility,
            "zone": zone,
            "timestamp": timestamp
          }
      
      # Update last seen and store state
      device_state["last_seen"] = timestamp
      device_state_store.put(key, json.dumps(device_state))
      
      return result_event
      
    expression: result if result else None
    resultType: json

pipelines:
  optimized_processing_pipeline:
    from: device_events
    via:
      - type: mapValues
        mapper: process_device_events
      - type: filter
        if:
          expression: value is not None
    to:
      topic: device_alerts
      keyType: string
      valueType: json