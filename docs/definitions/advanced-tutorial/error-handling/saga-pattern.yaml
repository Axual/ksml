# Saga Pattern Example
# This example demonstrates the saga pattern for managing
# distributed transactions across multiple services

name: saga-pattern-example
version: 1.0.0

# Input streams
streams:
  travel_bookings:
    topic: travel-booking-requests
    keyType: string
    valueType: json
    offsetResetPolicy: latest
  
  saga_events:
    topic: saga-events
    keyType: string
    valueType: json
    offsetResetPolicy: latest

# Output topics
producers:
  booking_confirmations:
    topic: booking-confirmations
    keyType: string
    valueType: json
  
  booking_failures:
    topic: booking-failures
    keyType: string
    valueType: json
  
  saga_commands:
    topic: saga-commands
    keyType: string
    valueType: json
  
  saga_compensation_commands:
    topic: saga-compensation-commands
    keyType: string
    valueType: json

# State stores
stores:
  saga_state:
    type: keyValue
    keyType: string  # saga_id
    valueType: json  # saga state machine
    persistent: true
  
  saga_log:
    type: keyValue
    keyType: string  # saga_id
    valueType: json  # event log
    persistent: true
  
  service_responses:
    type: keyValue
    keyType: string  # correlation_id
    valueType: json  # service response
    persistent: true

# Saga orchestration functions
functions:
  # Initialize saga for travel booking
  initialize_travel_saga:
    type: valueTransformer
    globalCode: |
      import time
      import uuid
      
      # Define saga steps for travel booking
      SAGA_DEFINITION = {
        "name": "travel_booking_saga",
        "steps": [
          {
            "name": "reserve_flight",
            "service": "flight-service",
            "command": "RESERVE_FLIGHT",
            "compensation": "CANCEL_FLIGHT",
            "timeout_ms": 30000
          },
          {
            "name": "reserve_hotel",
            "service": "hotel-service",
            "command": "RESERVE_HOTEL",
            "compensation": "CANCEL_HOTEL",
            "timeout_ms": 20000
          },
          {
            "name": "reserve_car",
            "service": "car-rental-service",
            "command": "RESERVE_CAR",
            "compensation": "CANCEL_CAR",
            "timeout_ms": 15000
          },
          {
            "name": "process_payment",
            "service": "payment-service",
            "command": "CHARGE_PAYMENT",
            "compensation": "REFUND_PAYMENT",
            "timeout_ms": 45000
          },
          {
            "name": "confirm_booking",
            "service": "booking-service",
            "command": "CONFIRM_BOOKING",
            "compensation": None,  # Final step, no compensation
            "timeout_ms": 10000
          }
        ]
      }
    code: |
      booking_request = value
      saga_id = f"saga_{booking_request.get('id', key)}_{uuid.uuid4().hex[:8]}"
      
      # Initialize saga state
      saga_state = {
        "saga_id": saga_id,
        "definition": SAGA_DEFINITION,
        "current_step": 0,
        "status": "STARTED",
        "booking_data": booking_request,
        "started_at": int(time.time() * 1000),
        "completed_steps": [],
        "failed_step": None,
        "compensation_index": -1
      }
      
      # Initialize saga log
      saga_log = [{
        "timestamp": saga_state["started_at"],
        "event": "SAGA_STARTED",
        "data": {"booking_id": booking_request.get("id")}
      }]
      
      # Store state
      state_stores.put("saga_state", saga_id, saga_state)
      state_stores.put("saga_log", saga_id, saga_log)
      
      return {
        "saga_id": saga_id,
        "status": "INITIALIZED",
        "first_command": SAGA_DEFINITION["steps"][0],
        "booking_data": booking_request
      }
    resultType: json
    stores:
      - saga_state
      - saga_log
  
  # Generate next saga command
  generate_saga_command:
    type: valueTransformer
    code: |
      import time
      import uuid
      
      saga_data = value
      saga_id = saga_data.get("saga_id")
      
      # Get current saga state
      saga_state = state_stores.get("saga_state", saga_id)
      if not saga_state:
        return {"error": "Saga not found"}
      
      current_step = saga_state.get("current_step", 0)
      steps = saga_state.get("definition", {}).get("steps", [])
      
      if current_step >= len(steps):
        return {"status": "SAGA_COMPLETED"}
      
      step = steps[current_step]
      correlation_id = f"{saga_id}_step_{current_step}_{uuid.uuid4().hex[:8]}"
      
      # Create command
      command = {
        "command_id": correlation_id,
        "saga_id": saga_id,
        "step_name": step["name"],
        "service": step["service"],
        "command_type": step["command"],
        "payload": self.prepare_command_payload(step, saga_state.get("booking_data", {})),
        "timeout_ms": step["timeout_ms"],
        "timestamp": int(time.time() * 1000)
      }
      
      # Update saga log
      log = state_stores.get("saga_log", saga_id) or []
      log.append({
        "timestamp": command["timestamp"],
        "event": "COMMAND_SENT",
        "step": step["name"],
        "correlation_id": correlation_id
      })
      state_stores.put("saga_log", saga_id, log)
      
      return command
    resultType: json
    stores:
      - saga_state
      - saga_log
  
  # Prepare command payload based on step
  prepare_command_payload:
    type: keyValueTransformer
    code: |
      step = key
      booking_data = value
      
      step_name = step.get("name", "")
      
      if step_name == "reserve_flight":
        return (step, {
          "passenger_name": booking_data.get("passenger_name"),
          "flight_number": booking_data.get("flight_number"),
          "departure_date": booking_data.get("departure_date"),
          "seat_class": booking_data.get("seat_class", "economy")
        })
      
      elif step_name == "reserve_hotel":
        return (step, {
          "guest_name": booking_data.get("passenger_name"),
          "hotel_id": booking_data.get("hotel_id"),
          "check_in_date": booking_data.get("check_in_date"),
          "check_out_date": booking_data.get("check_out_date"),
          "room_type": booking_data.get("room_type", "standard")
        })
      
      elif step_name == "reserve_car":
        return (step, {
          "driver_name": booking_data.get("passenger_name"),
          "car_category": booking_data.get("car_category", "compact"),
          "pickup_date": booking_data.get("departure_date"),
          "return_date": booking_data.get("return_date"),
          "pickup_location": booking_data.get("pickup_location")
        })
      
      elif step_name == "process_payment":
        return (step, {
          "amount": booking_data.get("total_amount"),
          "currency": booking_data.get("currency", "USD"),
          "payment_method": booking_data.get("payment_method"),
          "customer_id": booking_data.get("customer_id")
        })
      
      elif step_name == "confirm_booking":
        return (step, {
          "booking_id": booking_data.get("id"),
          "customer_email": booking_data.get("customer_email"),
          "booking_summary": {
            "flight": booking_data.get("flight_number"),
            "hotel": booking_data.get("hotel_id"),
            "car": booking_data.get("car_category")
          }
        })
      
      return (step, booking_data)
    resultType: (json, json)
  
  # Process saga event (service response)
  process_saga_event:
    type: valueTransformer
    globalCode: |
      import time
      
      def should_compensate(saga_state, event):
        # Determine if compensation is needed based on event
        if event.get("status") == "FAILED":
          return True
        if event.get("status") == "TIMEOUT":
          return True
        if saga_state.get("status") == "COMPENSATING":
          return True
        return False
    code: |
      event = value
      saga_id = event.get("saga_id")
      
      # Get saga state
      saga_state = state_stores.get("saga_state", saga_id)
      if not saga_state:
        return {"error": "Saga not found"}
      
      # Update saga log
      log = state_stores.get("saga_log", saga_id) or []
      log.append({
        "timestamp": int(time.time() * 1000),
        "event": "EVENT_RECEIVED",
        "data": event
      })
      state_stores.put("saga_log", saga_id, log)
      
      # Process based on saga status
      if saga_state["status"] == "COMPENSATING":
        # Handle compensation response
        if event.get("status") == "COMPENSATED":
          compensation_index = saga_state.get("compensation_index", -1)
          if compensation_index > 0:
            # Continue compensation
            saga_state["compensation_index"] = compensation_index - 1
            return {
              "action": "CONTINUE_COMPENSATION",
              "saga_id": saga_id,
              "next_compensation_index": compensation_index - 1
            }
          else:
            # Compensation complete
            saga_state["status"] = "COMPENSATED"
            saga_state["completed_at"] = int(time.time() * 1000)
            state_stores.put("saga_state", saga_id, saga_state)
            return {
              "action": "SAGA_COMPENSATED",
              "saga_id": saga_id
            }
      
      else:  # Normal flow
        if event.get("status") == "SUCCESS":
          # Step succeeded
          current_step = saga_state.get("current_step", 0)
          saga_state["completed_steps"].append({
            "step_index": current_step,
            "step_name": saga_state["definition"]["steps"][current_step]["name"],
            "response": event.get("response", {}),
            "completed_at": int(time.time() * 1000)
          })
          
          # Move to next step
          saga_state["current_step"] = current_step + 1
          
          # Check if saga is complete
          if saga_state["current_step"] >= len(saga_state["definition"]["steps"]):
            saga_state["status"] = "COMPLETED"
            saga_state["completed_at"] = int(time.time() * 1000)
            state_stores.put("saga_state", saga_id, saga_state)
            return {
              "action": "SAGA_COMPLETED",
              "saga_id": saga_id,
              "booking_data": saga_state.get("booking_data")
            }
          
          # Continue to next step
          state_stores.put("saga_state", saga_id, saga_state)
          return {
            "action": "CONTINUE",
            "saga_id": saga_id,
            "next_step": saga_state["current_step"]
          }
        
        else:  # Step failed
          # Mark failure
          saga_state["failed_step"] = {
            "index": saga_state.get("current_step", 0),
            "error": event.get("error", "Unknown error"),
            "timestamp": int(time.time() * 1000)
          }
          saga_state["status"] = "COMPENSATING"
          saga_state["compensation_index"] = len(saga_state["completed_steps"]) - 1
          
          state_stores.put("saga_state", saga_id, saga_state)
          
          return {
            "action": "START_COMPENSATION",
            "saga_id": saga_id,
            "failed_step": saga_state["failed_step"],
            "steps_to_compensate": len(saga_state["completed_steps"])
          }
    resultType: json
    stores:
      - saga_state
      - saga_log
  
  # Generate compensation command
  generate_compensation_command:
    type: valueTransformer
    code: |
      import time
      import uuid
      
      compensation_data = value
      saga_id = compensation_data.get("saga_id")
      
      # Get saga state
      saga_state = state_stores.get("saga_state", saga_id)
      if not saga_state:
        return {"error": "Saga not found"}
      
      compensation_index = saga_state.get("compensation_index", -1)
      completed_steps = saga_state.get("completed_steps", [])
      
      if compensation_index < 0 or compensation_index >= len(completed_steps):
        return {"error": "Invalid compensation index"}
      
      # Get the step to compensate
      completed_step = completed_steps[compensation_index]
      step_def = saga_state["definition"]["steps"][completed_step["step_index"]]
      
      if not step_def.get("compensation"):
        # No compensation needed for this step, skip
        saga_state["compensation_index"] = compensation_index - 1
        state_stores.put("saga_state", saga_id, saga_state)
        return {
          "action": "SKIP_COMPENSATION",
          "saga_id": saga_id,
          "next_index": compensation_index - 1
        }
      
      correlation_id = f"{saga_id}_comp_{compensation_index}_{uuid.uuid4().hex[:8]}"
      
      # Create compensation command
      command = {
        "command_id": correlation_id,
        "saga_id": saga_id,
        "step_name": step_def["name"],
        "service": step_def["service"],
        "command_type": step_def["compensation"],
        "payload": {
          "original_response": completed_step.get("response", {}),
          "booking_data": saga_state.get("booking_data", {})
        },
        "timeout_ms": step_def["timeout_ms"],
        "timestamp": int(time.time() * 1000),
        "is_compensation": True
      }
      
      # Update log
      log = state_stores.get("saga_log", saga_id) or []
      log.append({
        "timestamp": command["timestamp"],
        "event": "COMPENSATION_COMMAND_SENT",
        "step": step_def["name"],
        "correlation_id": correlation_id
      })
      state_stores.put("saga_log", saga_id, log)
      
      return command
    resultType: json
    stores:
      - saga_state
      - saga_log
  
  # Monitor saga status
  get_saga_status:
    type: valueTransformer
    code: |
      saga_id = value.get("saga_id", key)
      
      saga_state = state_stores.get("saga_state", saga_id)
      if not saga_state:
        return {"error": "Saga not found"}
      
      saga_log = state_stores.get("saga_log", saga_id) or []
      
      # Calculate metrics
      current_time = int(time.time() * 1000)
      duration = current_time - saga_state.get("started_at", current_time)
      
      completed_count = len(saga_state.get("completed_steps", []))
      total_steps = len(saga_state.get("definition", {}).get("steps", []))
      
      return {
        "saga_id": saga_id,
        "status": saga_state.get("status"),
        "progress": {
          "completed_steps": completed_count,
          "total_steps": total_steps,
          "percentage": (completed_count / total_steps * 100) if total_steps > 0 else 0
        },
        "duration_ms": duration,
        "current_step": saga_state.get("definition", {}).get("steps", [])[saga_state.get("current_step", 0)]["name"] 
                       if saga_state.get("current_step", 0) < total_steps else "completed",
        "failed_step": saga_state.get("failed_step"),
        "compensation_progress": {
          "is_compensating": saga_state.get("status") == "COMPENSATING",
          "compensation_index": saga_state.get("compensation_index", -1)
        },
        "recent_events": saga_log[-5:] if len(saga_log) > 5 else saga_log
      }
    resultType: json
    stores:
      - saga_state
      - saga_log

# Main saga orchestration pipeline
pipelines:
  saga_orchestrator:
    from: travel_bookings
    via:
      # Initialize saga
      - type: transformValue
        mapper: initialize_travel_saga
      
      # Generate first command
      - type: transformValue
        mapper: generate_saga_command
    
    to: saga_commands

# Saga event processor
pipelines:
  saga_event_processor:
    from: saga_events
    via:
      # Process event
      - type: transformValue
        mapper: process_saga_event
      
      # Branch based on action
      - type: branch
        branches:
          - name: continue_saga
            predicate:
              expression: value.get("action") == "CONTINUE"
          - name: start_compensation
            predicate:
              expression: value.get("action") == "START_COMPENSATION"
          - name: continue_compensation
            predicate:
              expression: value.get("action") == "CONTINUE_COMPENSATION"
          - name: saga_completed
            predicate:
              expression: value.get("action") == "SAGA_COMPLETED"
          - name: saga_compensated
            predicate:
              expression: value.get("action") == "SAGA_COMPENSATED"
    
    branch:
      continue_saga:
        via:
          # Generate next command
          - type: transformValue
            mapper: generate_saga_command
        to: saga_commands
      
      start_compensation:
        via:
          # Generate first compensation command
          - type: transformValue
            mapper: generate_compensation_command
        to: saga_compensation_commands
      
      continue_compensation:
        via:
          # Generate next compensation command
          - type: transformValue
            mapper: generate_compensation_command
          
          # Check if it's a skip
          - type: branch
            branches:
              - name: send_command
                predicate:
                  expression: value.get("action") != "SKIP_COMPENSATION"
              - name: skip
                predicate:
                  expression: value.get("action") == "SKIP_COMPENSATION"
        
        branch:
          send_command:
            to: saga_compensation_commands
          skip:
            # Process skip as an event to continue compensation
            via:
              - type: transformValue
                mapper:
                  expression: |
                    {
                      "saga_id": value.get("saga_id"),
                      "status": "COMPENSATED",
                      "skipped": True
                    }
                  resultType: json
            to: saga_events
      
      saga_completed:
        via:
          - type: peek
            forEach:
              expression: |
                print(f"Saga completed successfully: {value['saga_id']}")
        to: booking_confirmations
      
      saga_compensated:
        via:
          - type: peek
            forEach:
              expression: |
                print(f"Saga compensated: {value['saga_id']}")
        to: booking_failures

# Service simulators (would be separate services in production)
pipelines:
  command_processor_simulator:
    from: saga_commands
    via:
      # Simulate service processing
      - type: transformValue
        mapper:
          globalCode: |
            import random
            import time
          code: |
            command = value
            
            # Simulate processing delay
            time.sleep(random.uniform(0.1, 0.5))
            
            # Simulate response
            success_rate = 0.8  # 80% success rate
            
            if random.random() < success_rate:
              response = {
                "saga_id": command.get("saga_id"),
                "correlation_id": command.get("command_id"),
                "status": "SUCCESS",
                "response": {
                  "confirmation_number": f"{command.get('service')}_{random.randint(100000, 999999)}",
                  "processed_at": int(time.time() * 1000)
                }
              }
            else:
              response = {
                "saga_id": command.get("saga_id"),
                "correlation_id": command.get("command_id"),
                "status": "FAILED",
                "error": f"Service {command.get('service')} temporarily unavailable"
              }
            
            return response
          resultType: json
    
    to: saga_events

  compensation_processor_simulator:
    from: saga_compensation_commands
    via:
      # Simulate compensation processing
      - type: transformValue
        mapper:
          globalCode: |
            import random
            import time
          code: |
            command = value
            
            # Compensations have higher success rate
            success_rate = 0.95
            
            time.sleep(random.uniform(0.1, 0.3))
            
            if random.random() < success_rate:
              response = {
                "saga_id": command.get("saga_id"),
                "correlation_id": command.get("command_id"),
                "status": "COMPENSATED",
                "response": {
                  "compensation_id": f"comp_{random.randint(100000, 999999)}",
                  "compensated_at": int(time.time() * 1000)
                }
              }
            else:
              response = {
                "saga_id": command.get("saga_id"),
                "correlation_id": command.get("command_id"),
                "status": "COMPENSATION_FAILED",
                "error": "Failed to compensate"
              }
            
            return response
          resultType: json
    
    to: saga_events