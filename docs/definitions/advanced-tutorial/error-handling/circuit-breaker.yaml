# Circuit Breaker Pattern Example
# This example demonstrates how to implement a circuit breaker pattern in KSML
# to protect against cascading failures when calling external services

name: circuit-breaker-example
version: 1.0.0

streams:
  # Define the input stream of API requests
  api_requests:
    topic: api-requests
    keyType: string
    valueType: json
    offsetResetPolicy: latest

tables:
  # Define table to track circuit breaker state
  circuit_breaker_state:
    topic: circuit-breaker-state
    keyType: string  # service name
    valueType: json  # state: CLOSED, OPEN, HALF_OPEN

  # Output topics
  successful_responses:
    topic: api-responses
    keyType: string
    valueType: json

  failed_requests:
    topic: failed-api-requests
    keyType: string
    valueType: json

stores:
  # State stores for tracking failures
  failure_counter:
    type: keyValue
    keyType: string
    valueType: long
    persistent: true
  
  last_failure_time:
    type: keyValue
    keyType: string
    valueType: long
    persistent: true

# Reusable functions
functions:
  # Check if the circuit breaker should trip
  should_trip_circuit:
    type: predicate
    globalCode: |
      import time
      FAILURE_THRESHOLD = 5
      TIME_WINDOW_MS = 60000  # 1 minute
    code: |
      service_name = key
      current_time = int(time.time() * 1000)
      
      # Get failure count from state store
      failure_count = state_stores.get("failure_counter", service_name) or 0
      last_failure = state_stores.get("last_failure_time", service_name) or 0
      
      # Reset counter if outside time window
      if current_time - last_failure > TIME_WINDOW_MS:
        state_stores.put("failure_counter", service_name, 0)
        state_stores.put("last_failure_time", service_name, 0)
        return False
      
      # Check if threshold exceeded
      return failure_count >= FAILURE_THRESHOLD
    resultType: boolean
  
  # Check if the circuit should be opened
  is_circuit_open:
    type: predicate
    globalCode: |
      import time
      CIRCUIT_OPEN_DURATION_MS = 300_000  # 5 minutes
    code: |
      circuit_state = value.get("state", {})

      if circuit_state.get("status") != "OPEN":
        return False

      # Check if circuit should move to half-open
      current_time = int(time.time() * 1000)
      open_time = circuit_state.get("opened_at", 0)

      if current_time - open_time > CIRCUIT_OPEN_DURATION_MS:
        # Move to half-open state
        circuit_state["status"] = "HALF_OPEN"
        circuit_state["half_opened_at"] = current_time
        return False

      return True
    resultType: boolean
  
  # Process request with circuit breaker
  process_with_circuit_breaker:
    type: valueTransformer
    globalCode: |
      import time
      import random
      
      def call_external_service(request):
        # Simulate external service call
        # In real implementation, this would make actual HTTP/gRPC calls
        service = request.get("service")
        
        # Simulate 20% failure rate for demo
        if random.random() < 0.2:
          raise Exception(f"Service {service} failed")
        
        return {
          "status": "success",
          "data": request.get("data"),
          "timestamp": int(time.time() * 1000)
        }
    code: |
      service_name = value.get("service")
      circuit_state = state_stores.get("circuit_breaker_state", service_name) or {"status": "CLOSED"}
      
      # Check circuit state
      if circuit_state.get("status") == "OPEN":
        current_time = int(time.time() * 1000)
        open_time = circuit_state.get("opened_at", 0)
        
        # Check if should move to half-open
        if current_time - open_time > CIRCUIT_OPEN_DURATION_MS:
          circuit_state["status"] = "HALF_OPEN"
          circuit_state["half_opened_at"] = current_time
          state_stores.put("circuit_breaker_state", service_name, circuit_state)
        else:
          # Circuit is open, fail fast
          return {
            "error": "Circuit breaker is OPEN",
            "service": service_name,
            "retry_after": CIRCUIT_OPEN_DURATION_MS - (current_time - open_time)
          }
      
      try:
        # Attempt to call service
        response = call_external_service(value)
        
        # Success - update circuit state
        if circuit_state.get("status") == "HALF_OPEN":
          # Successful call in half-open state, close the circuit
          circuit_state = {"status": "CLOSED", "closed_at": int(time.time() * 1000)}
          state_stores.put("circuit_breaker_state", service_name, circuit_state)
        
        # Reset failure counter on success
        state_stores.put("failure_counter", service_name, 0)
        
        return response
        
      except Exception as e:
        # Failure - update counters
        current_time = int(time.time() * 1000)
        failure_count = (state_stores.get("failure_counter", service_name) or 0) + 1
        
        state_stores.put("failure_counter", service_name, failure_count)
        state_stores.put("last_failure_time", service_name, current_time)
        
        # Check if should trip circuit
        if failure_count >= FAILURE_THRESHOLD:
          circuit_state = {
            "status": "OPEN",
            "opened_at": current_time,
            "failure_count": failure_count,
            "last_error": str(e)
          }
          state_stores.put("circuit_breaker_state", service_name, circuit_state)
        
        # If in half-open state, immediately reopen circuit
        elif circuit_state.get("status") == "HALF_OPEN":
          circuit_state = {
            "status": "OPEN",
            "opened_at": current_time,
            "reopened_from_half_open": True
          }
          state_stores.put("circuit_breaker_state", service_name, circuit_state)
        
        return {
          "error": str(e),
          "service": service_name,
          "failure_count": failure_count,
          "circuit_status": circuit_state.get("status", "CLOSED")
        }
    resultType: json
    stores:
      - failure_counter
      - last_failure_time
      - circuit_breaker_state

pipelines:
  # Main processing pipeline
  circuit_breaker_pipeline:
    from: api_requests
    via:
      # Process requests with circuit breaker protection
      - type: transformValue
        mapper: process_with_circuit_breaker
    # Branch successful and failed requests
    branch:
      - if:
          expression: value.get("error") is not None
        to: failed_requests
      - to: successful_responses

  # Monitor circuit breaker state changes
  monitor_circuit_state:
    from: circuit_breaker_state
    via:
      - type: peek
        forEach:
          code: |
            log.info("Circuit breaker state change: {} -> {}", key, value)
