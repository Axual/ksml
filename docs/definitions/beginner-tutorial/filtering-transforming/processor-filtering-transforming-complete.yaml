streams:
  sensor_data:
    topic: tutorial_input
    keyType: string
    valueType: json
  processed_data:
    topic: filtered_data
    keyType: string
    valueType: json
  error_data:
    topic: alerts_stream
    keyType: string
    valueType: json

functions:
  validate_sensor_data:
    type: predicate
    code: |
      try:
        # Check if all required fields are present in the nested structure
        sensors = value.get('sensors', {})
        metadata = value.get('metadata', {})
      
        # Check if temperature data exists and has a value
        if 'temperature' not in sensors or 'value' not in sensors['temperature']:
          print(f"Missing temperature data in message: {value}")
          result = False
        elif 'humidity' not in sensors or 'value' not in sensors['humidity']:
          print(f"Missing humidity data in message: {value}")
          result = False
        elif 'timestamp' not in metadata:
          print(f"Missing timestamp in message: {value}")
          result = False
        else:
          # Validate temperature range
          temp_value = sensors['temperature']['value']
          if not isinstance(temp_value, (int, float)) or temp_value < -100 or temp_value > 200:
            print(f"Invalid temperature value: {temp_value}")
            result = False
          else:
            # Validate humidity range
            humidity_value = sensors['humidity']['value']
            if not isinstance(humidity_value, (int, float)) or humidity_value < 0 or humidity_value > 100:
              print(f"Invalid humidity value: {humidity_value}")
              result = False
            else:
              result = True
      except Exception as e:
        print(f"Error validating sensor data: {str(e)} - Message: {value}")
        result = False
    expression: result
    resultType: boolean

  transform_sensor_data:
    type: keyValueTransformer
    code: |
      from datetime import datetime
      
      try:
        # Extract nested sensor data
        sensors = value.get('sensors', {})
        metadata = value.get('metadata', {})
      
        # Get temperature and convert from F to C
        temp_f = sensors.get('temperature', {}).get('value', 0)
        temp_c = (temp_f - 32) * 5/9
      
        # Get humidity
        humidity = sensors.get('humidity', {}).get('value', 0)
      
        # Calculate heat index (simplified formula)
        heat_index = temp_c * 1.8 + 32 - 0.55 * (1 - humidity / 100)
      
        # Get location
        location = sensors.get('location', {}).get('value', 'unknown')
      
        # Format timestamp
        timestamp = metadata.get('timestamp', 0)
        if isinstance(timestamp, (int, float)):
          # Convert Unix timestamp to ISO format
          formatted_time = datetime.fromtimestamp(timestamp / 1000).isoformat()
        else:
          formatted_time = str(timestamp)
      
        transformed = {
          "sensor_id": key,
          "location": location,
          "readings": {
            "temperature": {
              "celsius": round(temp_c, 2),
              "fahrenheit": temp_f
            },
            "humidity": humidity,
            "heat_index": round(heat_index, 2)
          },
          "timestamp": formatted_time,
          "processed_at": int(time.time() * 1000)
        }
        new_key = key
        new_value = transformed
      except Exception as e:
        error_data = {
          "error": str(e),
          "original": value,
          "sensor_id": key,
          "timestamp": int(time.time() * 1000)
        }
        new_key = key
        new_value = error_data
    expression: (new_key, new_value)
    resultType: (string, json)

  log_processed_data:
    type: forEach
    code: |
      readings = value.get('readings', {})
      temp = readings.get('temperature', {}).get('celsius')
      humidity = readings.get('humidity')
      sensor_id = value.get('sensor_id')
      print(f"Processed sensor data for {sensor_id}: temp={temp}C, humidity={humidity}%")

pipelines:
  process_sensor_data:
    from: sensor_data
    via:
      - type: filter
        if: validate_sensor_data
      - type: transformKeyValue
        mapper: transform_sensor_data
      - type: peek
        forEach: log_processed_data
    branch:
      - if:
          expression: "'error' in value"
        to: error_data
      - to: processed_data