streams:
  sensor_readings:
    topic: sensor_readings
    keyType: string
    valueType: json
    
  sensor_averages:
    topic: sensor_moving_averages
    keyType: json:windowed(string)
    valueType: json

functions:
  initialize_average:
    type: initializer
    expression: {"sum": 0.0, "count": 0}
    resultType: json

  update_average:
    type: aggregator
    code: |
      # Initialize if first time
      if aggregatedValue is None:
        aggregatedValue = {"sum": 0.0, "count": 0}
      
      # Update sum and count
      aggregatedValue["sum"] += value.get("value", 0.0)
      aggregatedValue["count"] += 1
      
      new_value = aggregatedValue
    expression: new_value
    resultType: json
    
  calculate_final_average:
    type: valueTransformer
    code: |
      if value is None or value.get("count", 0) == 0:
        return None
      
      # Calculate average
      average = value["sum"] / value["count"]
      
      result = {
        "average": round(average, 2),
        "sample_count": value["count"],
        "total_sum": round(value["sum"], 2)
      }
    expression: result
    resultType: json

pipelines:
  moving_average_2min:
    from: sensor_readings
    via:
      - type: groupByKey
      - type: windowByTime
        windowType: hopping
        duration: 2m        # 2-minute windows
        advanceBy: 30s      # Move forward every 30 seconds (overlapping)
        grace: 10s
      - type: aggregate
        store:
          name: sensor_averages_hopping
          type: window
          windowSize: 2m
          retention: 10m
          caching: false
        initializer: initialize_average
        aggregator: update_average
      - type: toStream
      - type: convertKey
        into: json:windowed(string)
      - type: mapValues
        mapper: calculate_final_average
      - type: peek
        forEach:
          code: log.info("HOPPING AVERAGE (2min/30s) - sensor={}, avg={}", key, value.get("average") if value else None)
    to: sensor_averages