# Retry strategies with exponential backoff for transient failures

streams:
  api_operations:
    topic: api_operations
    keyType: string
    valueType: json
    
  successful_operations:
    topic: successful_operations
    keyType: string
    valueType: json
    
  failed_operations:
    topic: failed_operations
    keyType: string
    valueType: json

functions:
  process_with_retry:
    type: valueTransformer
    globalCode: |
      import random
      import math
      
      MAX_RETRIES = 3
      BASE_DELAY_MS = 1000
      
      def calculate_backoff_delay(attempt):
        # Exponential backoff: 1s, 2s, 4s
        delay = BASE_DELAY_MS * (2 ** attempt)
        # Add 20% jitter
        jitter = delay * 0.2 * (random.random() * 2 - 1)
        return int(delay + jitter)
        
    code: |
      operation_id = value.get("operation_id", "unknown")
      retry_count = value.get("retry_count", 0)
      should_fail = value.get("should_fail", False)
      failure_type = value.get("failure_type", "")
      
      # Determine if this operation should succeed or fail
      if not should_fail:
        # Success case
        result = {
          "operation_id": operation_id,
          "api_endpoint": value.get("api_endpoint"),
          "status": "success",
          "retry_count": retry_count,
          "final_attempt": True
        }
      else:
        # Check if error is retryable
        retryable_errors = ["network_timeout", "rate_limit", "server_error"]
        is_retryable = failure_type in retryable_errors
        
        if is_retryable and retry_count < MAX_RETRIES:
          # Increment retry count and calculate delay
          new_retry_count = retry_count + 1
          backoff_delay = calculate_backoff_delay(new_retry_count - 1)
          
          # Simulate: 30% chance of success after retry
          if random.random() < 0.3:
            result = {
              "operation_id": operation_id,
              "api_endpoint": value.get("api_endpoint"),
              "status": "success_after_retry",
              "retry_count": new_retry_count,
              "backoff_delay": backoff_delay,
              "final_attempt": True
            }
          else:
            result = {
              "operation_id": operation_id,
              "api_endpoint": value.get("api_endpoint"),
              "status": "retry_needed",
              "retry_count": new_retry_count,
              "failure_type": failure_type,
              "backoff_delay": backoff_delay,
              "final_attempt": new_retry_count >= MAX_RETRIES
            }
        else:
          # Not retryable or max retries exceeded
          result = {
            "operation_id": operation_id,
            "api_endpoint": value.get("api_endpoint"),
            "status": "permanent_failure",
            "retry_count": retry_count,
            "failure_type": failure_type,
            "final_attempt": True
          }
    
    expression: result
    resultType: json

pipelines:
  retry_processor:
    from: api_operations
    via:
      - type: transformValue
        mapper: process_with_retry
      - type: peek
        forEach:
          code: |
            status = value.get("status", "unknown")
            op_id = value.get("operation_id", "unknown")
            retry_count = value.get("retry_count", 0)
            
            if status == "success":
              log.info("API SUCCESS - {}: completed", op_id)
            elif status == "success_after_retry":
              log.info("API RETRY SUCCESS - {}: completed after {} retries", op_id, retry_count)
            elif status == "retry_needed":
              delay = value.get("backoff_delay", 0)
              log.warn("API RETRY - {}: attempt {} failed, retry in {}ms", op_id, retry_count, delay)
            else:
              log.error("API FAILED - {}: {}", op_id, value.get("failure_type"))
    branch:
      # Route successful operations
      - if:
          expression: value.get("status") in ["success", "success_after_retry"]
        to: successful_operations
      # Route failed operations
      - to: failed_operations