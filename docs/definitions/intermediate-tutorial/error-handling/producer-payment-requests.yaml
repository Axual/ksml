# Producer for dead letter queue example - generates payment requests with various conditions

functions:
  generate_payment_requests:
    type: generator
    globalCode: |
      import random
      counter = 0
    code: |
      global counter
      counter += 1
      
      # Generate different payment scenarios
      if counter % 6 == 1:
        # Valid payment
        payment = {
          "payment_id": f"pay_{counter}",
          "amount": round(random.uniform(10.0, 500.0), 2),
          "currency": "USD",
          "merchant_id": f"merchant_{random.randint(1, 3)}"
        }
      elif counter % 6 == 2:
        # Invalid amount
        payment = {
          "payment_id": f"pay_{counter}",
          "amount": -50.0,
          "currency": "USD",
          "merchant_id": f"merchant_{random.randint(1, 3)}"
        }
      elif counter % 6 == 3:
        # Missing required fields
        payment = {
          "payment_id": f"pay_{counter}",
          "amount": round(random.uniform(10.0, 500.0), 2)
        }
      elif counter % 6 == 4:
        # Invalid currency
        payment = {
          "payment_id": f"pay_{counter}",
          "amount": round(random.uniform(10.0, 500.0), 2),
          "currency": "INVALID",
          "merchant_id": f"merchant_{random.randint(1, 3)}"
        }
      elif counter % 6 == 5:
        # Retry-eligible error (temporary network issue simulation)
        payment = {
          "payment_id": f"pay_{counter}",
          "amount": round(random.uniform(10.0, 500.0), 2),
          "currency": "USD",
          "merchant_id": "temp_failure_merchant"
        }
      else:
        # Completely malformed
        payment = {"invalid": True, "data": counter}
      
      key = f"payment_{counter}"
    expression: (key, payment)
    resultType: (string, json)

producers:
  payment_producer:
    generator: generate_payment_requests
    interval: 2s
    count: 18
    to:
      topic: payment_requests
      keyType: string
      valueType: json