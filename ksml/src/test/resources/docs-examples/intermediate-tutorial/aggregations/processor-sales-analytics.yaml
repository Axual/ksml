streams:
  sales_events:
    topic: retail_sales
    keyType: string  # Product ID
    valueType: json  # Sale details including region, amount, quantity
    
  sales_by_region:
    topic: sales_by_region
    keyType: string  # Region
    valueType: json  # Aggregated sales statistics

functions:
  extract_region:
    type: keyValueMapper
    code: |
      # Extract region from the sale event and use it as the new key
      region = value.get("region", "unknown")
    expression: (region, value)
    resultType: (string, json)
  
  initialize_sales_stats:
    type: initializer
    expression: {"total_sales": 0.0, "total_quantity": 0, "transaction_count": 0, "products": {}}
    resultType: json
  
  aggregate_sales:
    type: aggregator
    code: |
      # Initialize aggregatedValue if None (first aggregation)
      if aggregatedValue is None:
        aggregatedValue = {"total_sales": 0.0, "total_quantity": 0, "transaction_count": 0, "products": {}}
      
      # Extract data from the sale
      product_id = value.get("product_id", "unknown")
      amount = value.get("amount", 0)
      quantity = value.get("quantity", 0)
      
      # Update aggregated values
      aggregatedValue["total_sales"] += amount
      aggregatedValue["total_quantity"] += quantity
      aggregatedValue["transaction_count"] += 1
      
      # Track per-product statistics
      if product_id not in aggregatedValue["products"]:
        aggregatedValue["products"][product_id] = {"sales": 0.0, "quantity": 0}
      
      aggregatedValue["products"][product_id]["sales"] += amount
      aggregatedValue["products"][product_id]["quantity"] += quantity
      
      # Calculate average sale
      aggregatedValue["avg_sale"] = round(aggregatedValue["total_sales"] / aggregatedValue["transaction_count"], 2)
      
      return aggregatedValue
    resultType: json
  
  transform_window_key:
    type: keyValueMapper
    code: |
      # Extract window information from the WindowedString key
      region = key["key"]
      window_start = key["startTime"]
      window_end = key["endTime"]
      
      # Create a new string key with window info
      new_key = f"{region}_{window_start}_{window_end}"
      
      # Add window metadata to the value
      new_value = {
        "region": region,
        "window_start": window_start,
        "window_end": window_end,
        "stats": value
      }
    expression: (new_key, new_value)
    resultType: (string, json)

pipelines:
  regional_sales_analytics:
    from: sales_events
    via:
      # Group by region instead of product ID
      - type: map
        mapper: extract_region
      - type: groupByKey
      # Use tumbling window of 1 minute for demo
      - type: windowByTime
        windowType: tumbling
        duration: 1m
        grace: 10s
      # Aggregate sales data
      - type: aggregate
        store:
          type: window
          windowSize: 1m
          retention: 10m
        initializer: initialize_sales_stats
        aggregator: aggregate_sales
      - type: toStream
      - type: map
        mapper: transform_window_key
      - type: peek
        forEach:
          code: |
            region = value["region"]
            stats = value["stats"]
            log.info("Region {} sales (1-min window): ${} from {} transactions", 
                     region, stats["total_sales"], stats["transaction_count"])
    # Output to region-specific topic
    to: sales_by_region