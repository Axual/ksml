# Processor demonstrating serialization optimization patterns

streams:
  binary_events:
    topic: binary_events
    keyType: string
    valueType: json

  optimized_events:
    topic: optimized_events
    keyType: string
    valueType: json

functions:
  efficient_binary_processor:
    type: valueTransformer
    globalCode: |
      # Lookup tables for efficient conversion (avoid string operations)
      EVENT_TYPES = {1: "view", 2: "click", 3: "purchase", 4: "search", 5: "logout"}
      
      def create_optimized_output(data, event_type):
        """Create optimized JSON output with structured data"""
        return {
          "processed_event": {
            "type": event_type,
            "user_id": data["user_id"],
            "value": data["value"],
            "score": data["score"],
            "timestamp": data["timestamp"]
          },
          "metadata": data.get("metadata", {}),
          "processing_info": {
            "optimized": True,
            "version": "v2"
          }
        }
        
    code: |
      # Extract data from JSON (more readable than binary parsing)
      user_id = value.get("user_id")
      timestamp = value.get("timestamp")
      event_type_id = value.get("event_type_id")
      current_value = value.get("value", 0)
      score = value.get("score", 0)
      
      # Early filtering based on score
      if score < 10:  # Filter low-quality events
        return None
      
      # Efficient processing with direct field access
      if event_type_id == 3:  # Purchase events
        # Apply purchase-specific logic
        processed_value = int(current_value * 1.1)  # 10% bonus
        final_score = min(score + 20, 100)  # Bonus capped at 100
      else:
        processed_value = current_value
        final_score = score
      
      # Get event type name for output
      event_type = EVENT_TYPES.get(event_type_id, "unknown")
      
      # Create optimized JSON output
      optimized_data = {
        "user_id": user_id,
        "timestamp": timestamp,
        "event_type_id": event_type_id,
        "value": processed_value,
        "score": final_score
      }
      
      result = create_optimized_output(optimized_data, event_type)
      
      return result
      
    expression: result if result else None
    resultType: json

  convert_to_readable:
    type: valueTransformer
    code: |
      # Convert optimized JSON to human-readable final format
      processed_event = value.get("processed_event", {})
      if not processed_event:
        return None
      
      event_type = processed_event.get("type", "unknown")
      user_id = processed_event.get("user_id")
      event_value = processed_event.get("value")
      score = processed_event.get("score")
      timestamp = processed_event.get("timestamp")
      
      # Create final readable JSON output for Kowl UI
      readable = {
        "summary": f"EVENT:{event_type} USER:{user_id} VALUE:{event_value} SCORE:{score}",
        "details": {
          "event_type": event_type,
          "user_id": user_id,
          "value": event_value,
          "score": score,
          "timestamp": timestamp
        },
        "metadata": value.get("metadata", {}),
        "processing_info": value.get("processing_info", {})
      }
      
      return readable
      
    expression: result if result else None
    resultType: json

pipelines:
  # High-performance processing pipeline
  binary_processing_pipeline:
    from: binary_events
    via:
      - type: mapValues
        mapper: efficient_binary_processor
      - type: filter
        if:
          expression: value is not None
    to:
      topic: optimized_events
      keyType: string
      valueType: json

  # Convert to readable format for final output
  readable_output_pipeline:
    from: optimized_events
    via:
      - type: mapValues
        mapper: convert_to_readable
      - type: filter
        if:
          expression: value is not None
    to:
      topic: readable_events
      keyType: string
      valueType: json